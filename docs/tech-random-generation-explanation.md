# How Random Generation Works

Let's first explain how it works on the surface in main.cpp and then dive into the ocean of details.
For a graphical observation of how a non-graphical labyrinth is made, hit right arrow twice to move outside
of bounds of button selection, then hit enter.
In the debug mode for random generation, hit keys g,v,b,n. 

## Implementation in main.cpp
    //set dimenstions of grid labyrinth will use for generating map
    
    //randomly set number of nodes in labyrinth to generate
    
    //if able to generate labyrinth
    if( thisLabyrinth.generateLabyrinth(rng) )
    {
        
       
        //generate graphical dungeons in Labyrinth, pass pointers to media information to keys and doors
        
	    //randomly set where exit in maze is
        
        //randomly place doors in labyrinth
        
        
        //set up all the tiles in labyrinth given the information placed by generating graphical dungeon
        
        
        //setup weapons in labyrinth
        
        //setup default weapon for player
        
        //have game inventory place default weapon next to player in game
        
        
        //initialize sub map from labyrinth
        
        //set where to render sub map in camera
        
        //Setup camera for collision system
        
        //setup fps timer
        
         //set camera for labyrinth 
        
        //add labyrinth enemy collision objects to collision handler
		
        //add hole tile collision objects of hole tiles in labyrinth to collision handler
    }


## Non-graphical Labyrinth, a collection of nodes randomly generated. Maze is generated.
The labyrinth first starts off as an empty room.

1. The grid is set up with Labyrinth::setGridDimensions(std::int16_t& x,std::int16_t& y,std::int16_t& w,std::int16_t& h). Now the labyrinth is an empty square.

2. Then, the number of nodes that should be inside the labyrinth is randomly generated by void Labyrinth::randomlySetNumberOfNodesToGenerate(RNGType& rngSeed). The labyrinth gets columns and rows at this stage.
 * It is actually not randomly generated at the time of this writing. 
 * The nodes have a width and height value of 20x20. 
 * The number of nodes is the product of the number of columns and number of rows in grid.  
 * The number of columns = gridWidth/nodeWidth.
 * The number of rows = gridLength / nodeLength. 

3. Inside Labyrinth::generateLabyrinth(RNGType& rngSeed), Labyrinth is further developed by generating nodes, and picking which nodes to keep.   
 * Class NodeGenerator takes in number of nodes in labyrinth and grid dimensions of labyrinth.
 * With this information, NodeGenerator generates nodes with NodeGenerator::generateNodes(rngSeed) and then chooses nodes to keep with NodeGenerator::chooseNodesRandomly(rngSeed).

4. After nodes are chosen in Labyrinth, a maze is created in Labyrinth::generateLabyrinthMaze(rngSeed).
 * Class MazeGenerator is used to generate the maze in the labyrinth.
 * MazeGenerator takes in collection of nodes kept from NodeGenerator using MazeGenerator::loadResourcesFromNodeGenerator(NodeGenerator* node_gen), and then generates the maze with MazeGenerator::generateMaze(rngSeed).
 * MazeGenerator uses Prim's algorithm to generate maze including setting walls and openings.
   * Reference: https://weblog.jamisbuck.org/2011/1/10/maze-generation-prim-s-algorithm

## Graphical labyrinth made from non-graphical labyrinth
1. After the maze is created, graphical labyrinth is made in function Labyrinth::generateDungeonsInLabyrinth(RNGType& rngSeed, 
                                              LTexture& keyTexture,
                                                ALuint& keySource,
                                                ALuint& keyBuffer,
                                                LTexture& doorTexture,
                                                ALuint& doorSource,
                                                ALuint& doorOpenSound,
                                                ALuint& doorFailSound,
                                                std::vector <SDL_Rect> *doorClips)
 1. A vector of LabyrinthNodes is created and made to be the same size as vector of Nodes in MazeGenerator.
 * Labyrinth::setupLabyrinthMapTiles(rngSeed,tempLabyrinthNodes) is called to individually generate a small map in each labyrinth node with information given from MazeGenerator on where the walls are.
 * Labyrinth::setupLabyrinthDoors(rngSeed,tempLabyrinthNodes,
                                 keyTexture,keySource,keyBuffer,
                                 doorTexture,doorSource,doorOpenSound,doorFailSound,
                                 doorClips) is called to randomly place doors in labyrinth.
 * Enemies are created by enemy inventory and then placed randomly in LabyrinthNodes vector.
 *  Class LabyrinthMap is used to put hole tiles and doors in LabyrinthNodes elements of vector. Then, it sets up clips to render from the tile sheet.

The graphical labyrinth is now finished. It is just a collection of LabyrinthNodes conencted together.

## Populating the Labyrinth with Important Actors and Objects
1. Labyrinth::setupDotInLabyrinth(SCREEN_WIDTH, SCREEN_HEIGHT,
                                      &camera) is called to setup camera to track main player and then randomly place main player inside the maze.
        
* Labyrinth::randomlySetExitForMaze(rng) is called to randomly set location of golden tile a reasonalbe distance from the player.
* Labyrinth::randomlySetLabyrinthDoors(rng) is called to randomly determine locations of doors and place the doors in the locations.
* Labyrinth::setTiles() sets up clips to renderr from tilesheet based on which tiles are supposed to be there.
